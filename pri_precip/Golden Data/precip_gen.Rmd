---
title: "Precip Golden Data"
author: "Derek Smith"
date: "Tuesday, January 26, 2016"
output: html_document
---

```{r,echo=FALSE}
seed<-1234
seed1<-1234
seed2<-2345
seed3<-3456
baseline<-42
size<-2000
```

```{r,echo=FALSE}
#function to determine the rain fall intensity
freq<-function(lam){
  set.seed(seed)
  if(lam=="low"){
 precip_freq<<-rpois(n=size, lambda=0.001) 
  
}

else if(lam=="medium"){
 precip_freq<<-rpois(n=size, lambda=0.005)   
  
}

else if(lam=="high"){
precip_freq<<-rpois(n=size, lambda=0.01) 
  
}

else(return("Invalid Precip Rate"))}
```

```{r,echo=FALSE}
## Set the rain fall frequency
## choices include "low", "medium", and "high"
lam<-"high"
freq(lam=lam)
```



```{r, echo=FALSE}
#generate precip amounts
set.seed(seed)
precip_amt<-rnorm(size,mean=0.5,sd=0.2)

#expected preip
expPrecip<-precip_amt*precip_freq


#cumulative sum of precips
cumPrecip<-cumsum(expPrecip)

#add on initial starting point for gauge
precipTotals<-cumPrecip+baseline
```


```{r, echo=FALSE}
## function to determine the noise level on the first wire
noiseLevel1<-function(no1=no1){
set.seed(seed1)

if(no1=="low"){
noise1<<-rnorm(size,mean=0,sd=0.01) 
}

else if(no1=="medium"){
 noise1<<-rnorm(size,mean=0,sd=0.1) 
}
else if (no1=="high"){
 noise1<<-rnorm(size,mean=0,sd=0.5) 
}
else(return("Invalid Noise Selection"))
}
```


```{r, echo=FALSE}
## function to determine the noise level on the second wire
noiseLevel2<-function(no2=no2){
set.seed(seed2)

if(no2=="low"){
noise2<<-rnorm(size,mean=0,sd=0.01) 
}

else if(no2=="medium"){
 noise2<<-rnorm(size,mean=0,sd=0.1) 
}
else if (no2=="high"){
 noise2<<-rnorm(size,mean=0,sd=0.5) 
}
else(return("Invalid Noise Selection"))
}
```

```{r, echo=FALSE}
## function to determine the noise level on the third wire
noiseLevel3<-function(no3=no3){
set.seed(seed3)

if(no3=="low"){
noise3<<-rnorm(size,mean=0,sd=0.01) 
}

else if(no3=="medium"){
 noise3<<-rnorm(size,mean=0,sd=0.1) 
}
else if (no3=="high"){
 noise3<<-rnorm(size,mean=0,sd=0.5) 
}
else(return("Invalid Noise Selection"))
}
```



```{r,echo=FALSE}
## Set the noise level of the strain gauges
## choices include "low", "medium", and "high"
no1<-"high"
no2<-"low"
no3<-"low"

noiseLevel1(no1=no1)
noiseLevel2(no2=no2)
noiseLevel3(no3=no3)
```

```{r,echo=FALSE}
wire1<-noise1+precipTotals
wire2<-noise2+precipTotals
wire3<-noise3+precipTotals

wires<-cbind(wire1,wire2,wire3)
```

```{r, echo=FALSE}
###########################################
## Convert to frequency values
#########################################
# Using calibration coefficients from maximo ID #13824

##Gauge 1
c1_1<-0.037648688452734

c2_1<-0.000019848113082

f0_1<-1090.27


##Gauge 2
c1_2<-0.036118604101687

c2_2<-0.000020559340411

f0_2<-1069.67

#Gauge 3
c1_3<-0.041028978386614

c2_3<-0.000017183088270

f0_3<-1055.82


######################
##  Determine frequency from depth
######################
a1<-c2_1
b1<-(-2*c2_1*f0_1)+c1_1


a2<-c2_2
b2<-(-2*c2_2*f0_2)+c1_2

a3<-c2_3
b3<-(-2*c2_3*f0_3)+c1_3

c1<-(-f0_1*c1_1)+(c2_1*f0_1^2)-wire1
wire1Freq<-((-1*b1)+sqrt(b1^2-4*a1*c1))/(2*a1)

c2<-(-f0_2*c1_2)+(c2_2*f0_2^2)-wire2
wire2Freq<-((-1*b2)+sqrt(b2^2-4*a2*c2))/(2*a2)


c3<-(-f0_3*c1_3)+(c2_3*f0_3^2)-wire3
wire3Freq<-((-1*b3)+sqrt(b3^2-4*a3*c3))/(2*a3)


wireFreq<-data.frame(cbind(wire1Freq,wire2Freq,wire3Freq))

##############################################
## Replicate values for a five minute period
##############################################

repFreq<-wireFreq[rep(row.names(wireFreq),times=30),]

##create a numeric vector of row numbers to sort by
repFreq$rowNum<-as.numeric(row.names(repFreq))

##Sort the data set by the row numbers
finalFreq<-repFreq[order(repFreq$rowNum),]

```


```{r, echo=FALSE}
#################################
## Add timestamps frequencies
#################################
start <- as.POSIXct("2012-01-15",tz="UTC")
interval <- 10

##Normal R time format
time<-seq(from=start, by=interval, length.out=nrow(finalFreq))

##Time formatted for CI
#time<-format(seq(from=start, by=interval, length.out=nrow(finalFreq)),"%d-%b-%y %I.%M.%OS3 %p")

precip<-data.frame(time=time,Freq1=finalFreq$wire1Freq,Freq2=finalFreq$wire2Freq,Freq3=finalFreq$wire3Freq)
```


```{r,echo=FALSE}
### add gaps into the data set

gap<-function(data=NA,nGaps=1,minGap=1,maxGap=1){
  
  
  ##number of columns in dataset
  colNum<-ncol(data)
  
  ##vector the length of the data set
  len<-1:nrow(data)
  
  #length of data set
  end<-nrow(data)
  
  ##gap indicator
  gaps<-rep(0,nrow(data))
  
  #data with gaps
  data.gap<-data
  
  for(i in 1:nGaps){
    #set.seed(seed)
    dur<-sample(minGap:maxGap,size=1) #duration of gap
    gapStart<-sample(len, size=1) #Start of gap in data
    gapEnd<-gapStart+dur #End point of gap in data
    
    if(gapEnd <= end){
      data.gap[gapStart:gapEnd,c(2:colNum)]<-NA #input NA into data set for the gap
      gaps[gapStart:gapEnd]<-rep(1,dur) #update indicator variable for the gap period
      
    }
    
    if(gapEnd > end){
      gapEnd<-end
      data.gap[gapStart:gapEnd,c(2:colNum)]<-NA #input NA into data set for the gap
      gaps[gapStart:gapEnd]<-rep(1,dur) #update indicator variable for the gap period
      
    }
    
    
  }
  
cleanData<<-data.frame(data)

data.gap$gapQF<-gaps
gapData<<-data.frame(data.gap)
  
  
}


```

```{r, echo=FALSE,warning=FALSE}
nGaps<-100
minGap<-50
maxGap<-100
gap(data=precip,nGaps=nGaps,minGap=minGap,maxGap=maxGap)

```


```{r, echo=FALSE}

##Write data sets to file

write.table(gapData,"C:\\Users\\Derek\\Documents\\NEON\\pri_precip\\Golden Data\\priPrecip_gap_goldenData_maxID_13824.csv",row.names=FALSE,sep=",")

write.table(cleanData,"C:\\Users\\Derek\\Documents\\NEON\\pri_precip\\Golden Data\\all_priPrecip_clean_goldenData_maxID_13824.csv",row.names=FALSE,sep=",")


```


#Overview of precipitation golden data

The golden data set was created with the following inputs

* A seed `r seed`.
* An initial bucket starting point of `r baseline` mm.
* A `r lam` intensity rain event.
* The size of the golden data set in terms of the number of 5 minute averages is `r size`.
* Gauge nosie was set to `r no1` using seed `r seed1` for gauge 1, `r no2` using seed `r seed2` for gauge 2, and `r no3` using seed `r seed3` for gauge 3.
* There are `r nGaps` gaps throughout the data set of 0.1 Hz data ranging in size from ` r minGap` to `r maxGap`.


```{r,echo=FALSE}


##########################################################
##inputs
#The largest step in precip allowed between time stamps
giantStep<-25

#The largest difference allowed among the wire deltas
deltaThreshold<-0.5

## Low depth range
Depth_Range_Low<--10

##########################################################

##Load raw frequency data
data<-gapData



data$DEPTH1<-c1_1*(data$Freq1-f0_1)+(c2_1*((data$Freq1-f0_1)^2))
data$DEPTH2<-c1_2*(data$Freq2-f0_2)+(c2_2*((data$Freq2-f0_2)^2))
data$DEPTH3<-c1_3*(data$Freq3-f0_3)+(c2_3*((data$Freq3-f0_3)^2))

#######################################################################

##create one minute means over the time series
precip.min.means <- aggregate(data[,c(2,3,4,6,7,8)], list(time=cut(data$time,breaks="min")),mean,na.rm = TRUE)

#################################################
##summarize the number of gaps in the data set
data$gapQF<-as.numeric(data$gapQF)
gap.min.means <- aggregate(data$gapQF, list(time=cut(data$time,breaks="min")),sum,na.rm = TRUE)

##If the number of gaps in a one minute average is >=6 then that time stamp is a gap. Thus a vector is added to the precip.min.means 
precip.min.means$gapQF<-ifelse(gap.min.means$x < 6,0,1)

## convert time stamps to posixct
precip.min.means$time<-as.POSIXct(precip.min.means$time)

##Subset the one minute means at five minute increments

#create a vector for the minutes
precip.min.means$min<-format(precip.min.means$time,"%M")


#subset the data set at five minute increments
data<-precip.min.means[precip.min.means$min=="00" |precip.min.means$min=="05"|precip.min.means$min=="10"|precip.min.means$min=="15"|precip.min.means$min=="20"|precip.min.means$min=="25"|precip.min.means$min=="30"|precip.min.means$min=="35"|precip.min.means$min=="40"|precip.min.means$min=="45"|precip.min.means$min=="50"|precip.min.means$min=="55",]






##compute the aveage depth for the strain gauge over the 3 hour period
##First determine the difference between depth measurements. If an NA exists then look two steps back for the difference

#temp vectors for lagged differences
x<-as.numeric(c(NA,diff(data$DEPTH1,lag=1,differences=1)))
y<-as.numeric(c(NA,NA,diff(data$DEPTH1,lag=2,differences=1)))

#final lagged differences for strain gauge 1
data$delta1<-ifelse(!is.na(x),x,y)

#temp vectors for lagged differences
x<-as.numeric(c(NA,diff(data$DEPTH2,lag=1,differences=1)))
y<-as.numeric(c(NA,NA,diff(data$DEPTH2,lag=2,differences=1)))

#final lagged differences for strain gauge 2
data$delta2<-ifelse(!is.na(x),x,y)



#temp vectors for lagged differences
x<-as.numeric(c(NA,diff(data$DEPTH3,lag=1,differences=1)))
y<-as.numeric(c(NA,NA,diff(data$DEPTH3,lag=2,differences=1)))

#final lagged differences for strain gauge 3
data$delta3<-ifelse(!is.na(x),x,y)



##compute the average of all three depths for a given timestamp

del123<-cbind(data[,"delta1"],data[,"delta2"],data[,"delta3"])

data$aveDelta<-apply(del123,MARGIN=1,FUN=mean)








########################
########################
######################
## Precip algorithm that looks at 3 hr chunks of data but process only the last hour
########################
########################
########################

##create indicators for the various flags


precipOut<-c()

dep<-as.numeric(nrow(data))
for(i in 1:((nrow(data)/12)-2)){
  
 

  sindex<-(i*12)-11
  eindex<-24+(i*12)
  x<-data[sindex:eindex,]

  
  ##############################
  ##Wire Weights - Inverse Delta Variance
  ##############################

########################################
#USCRN code chunk - calculateWireweights
########################################

  
  ##Determine numer of complete cases for the delta variance
  d1n<-ifelse(sum(complete.cases(x$delta1))>=sum(complete.cases(x$aveDelta)),sum(complete.cases(x$aveDelta)),sum(complete.cases(x$delta1)))
  
  d2n<-ifelse(sum(complete.cases(x$delta2))>=sum(complete.cases(x$aveDelta)),sum(complete.cases(x$aveDelta)),sum(complete.cases(x$delta2)))
  
  d3n<-ifelse(sum(complete.cases(x$delta3))>=sum(complete.cases(x$aveDelta)),sum(complete.cases(x$aveDelta)),sum(complete.cases(x$delta3)))
  
  
  
  deltaVar1<-1/(sum((x$delta1-x$aveDelta)^2,na.rm=TRUE)/(d1n-1))
  
  deltaVar2<-1/(sum((x$delta2-x$aveDelta)^2,na.rm=TRUE)/(d2n-1))
  
  deltaVar3<-1/(sum((x$delta3-x$aveDelta)^2,na.rm=TRUE)/(d3n-1))
  
  
  ######################################################
  ## Scale the wire weights so that they are out of 1
  ######################################################

####################################
#USCRN code chunk - zeroOutLowWires 
####################################
##Determine if any of the depths from this wire are unreasonably low, i.e., < -10. If TRUE set the delta variance for that wire to zero otherwise keep the previously calcualted delta variance for the wire.
  
##Wire 1
  
if(any(x[,c("DEPTH1")]< Depth_Range_Low,na.rm=TRUE)){
  
  deltaVar1<-0
}else{
  deltaVar1<-deltaVar1}
  
##Wire 2

if(any(x[,c("DEPTH2")]< Depth_Range_Low,na.rm=TRUE)){
  
  deltaVar2<-0
}else{
  deltaVar2<-deltaVar2}


##Wire 3

if(any(x[,c("DEPTH3")]< Depth_Range_Low,na.rm=TRUE)){
  
  deltaVar3<-0
}else{
  deltaVar3<-deltaVar3}

##create indicator based on results
if(any(x[,c("DEPTH1","DEPTH2","DEPTH3")]< Depth_Range_Low,na.rm=TRUE)){
  
lowDepth<-1

}else{
  lowDepth<-0
}




#########################################
#USCRN code chunk - zeroWhereDeltaAnomaly 
#########################################

##Sometimes problems can occur in the first period (i.e., the current hour being processed) where a bad wire returns to normal. If this occurs the wire's weight is set to 0. If the absolute value of a wire's delta is greater than the largest step possible "giantStep" it is defined as a bad wire here and it's weight is set to zero.


##Wire 1

if(any(abs(x[25:36,"delta1"]) > giantStep,na.rm=TRUE)){
  
  deltaVar1<-0
}else{
  deltaVar1<-deltaVar1}

##Wire 2

if(any(abs(x[25:36,"delta2"]) > giantStep,na.rm=TRUE)){
  
  deltaVar2<-0
}else{
  deltaVar2<-deltaVar2}


##Wire 3

if(any(abs(x[25:36,"delta3"]) > giantStep,na.rm=TRUE)){
  
  deltaVar3<-0
}else{
  deltaVar3<-deltaVar3}

##create indicator based on results
if(any(abs(x[25:36,c("delta1","delta2","delta3")]) > giantStep,na.rm=TRUE)){
  
  giant<-1
  
}else{
  giant<-0
}

###################################
#USCRN code chunk - atLeastTwoZeros
###################################

##Check to see if more than two wires are missing/bad if so then set the scaled weight to 0 for each wire so that 0 precip is calculated for the hour. Otherwise calculate the scaled weight for each wire.
if(sum(as.logical(c(deltaVar1==0,deltaVar2==0,deltaVar3==0)))>=2){
  
  ##Scale the weight for wire 1
  
  scaledWireWeight1<-0
  
  ##Scale the weight for wire 2
  
  scaledWireWeight2<-0
  
  ##Scale the weight for wire 3
  
  scaledWireWeight3<-0
  
  ##indicator for missingWireInfoQF
  missingWire<-1
  
  
  }else{

##################################
##USCRN code chunk - normalizeTo1
##################################    

##Determine the total weights
totWeights<-(deltaVar1+deltaVar2+deltaVar3)

##Scale the weight for wire 1

scaledWireWeight1<-deltaVar1/totWeights

##Scale the weight for wire 2

scaledWireWeight2<-deltaVar2/totWeights

##Scale the weight for wire 3

scaledWireWeight3<-deltaVar3/totWeights

##indicator for missingWireInfoQF
missingWire<-0
}

##############################################
#USCRN code chunk - weightedAverageOfDeltas
##############################################

  dep<-cbind(x$time[25:36],x$delta1[25:36],x$delta2[25:36],x$delta3[25:36],(scaledWireWeight1*x$delta1[25:36])+(scaledWireWeight2*x$delta2[25:36])+(scaledWireWeight3*x$delta3[25:36]),rep(lowDepth,times=12),rep(giant,times=12),rep(missingWire,times=12),x$gapQF[25:36])
    
  precipOut<-rbind(precipOut,dep)

  
}



##create column headers
colnames(precipOut)<-c("time","delta1","delta2","delta3","intPrecip","lowDepthQF","exDeltaQF","missingWireInfoQF","gapQF")

##Convert matrix to data frame
precipOut<-as.data.frame(precipOut)

##Convert seconds since epoch timestamp back to posixCT 
precipOut$time<-as.POSIXct(precipOut$time, origin="1970-01-01",tz="UTC")

## Convert all NAs in dataframe to zero
precipOut[is.na(precipOut)]<-0

```

```{r, echo=FALSE}

#########################################
#USCRN code chunk - zeroIfDivergentDeltas
#########################################


## Function to zero out precip values when the deltas among wires differ from one another too much. Threshold is deinfed as deltaThreshold under the inputs. Function finds the minimum and maximum delta for each time stamp and then subtracts the max from the min and assess whether this value is greater than the threshold. If it is then the modified precipitation value is set to zero if not then the modified precipitation value is carried through.

zeroIfDivergent<-function(deltas,modifiedPrecip,deltaThreshold){
  
  maxValue<-apply(deltas,MARGIN=1,FUN=max)
  
  minValue<-apply(deltas,MARGIN=1,FUN=min)
  
  maxMinDiff<-maxValue-minValue
  
  precipOut$adjPrecip<<-ifelse(maxMinDiff>deltaThreshold,0,modifiedPrecip)
  
  precipOut$gaugeNoiseQF<<-ifelse(maxMinDiff>deltaThreshold,1,0)
}


##If wire deltas deviate too much from one another set the modified precip value to zero otherwise carry the modified precip value through

zeroIfDivergent(deltas=precipOut[,c("delta1","delta2","delta3")],modifiedPrecip=precipOut$intPrecip,deltaThreshold)

```


```{r, echo=FALSE}

############################################
#USCRN code chunk - zeroIfNonpositiveDelta
#############################################

##Zero out any precip where nonpositive deltas were present from one or more of the strain gauges

## Function that assess whether any of the delta's from the three wires is not positive. If so then the adjPrecip value is set to zero if not then the adjPrecip value is carried through.


zeroIfNonpositiveDelta<-function(deltas,adjustedPrecip){
  
  precip<-c()
  results<-c()
  wireNoise<-c()
  
  ##Convert any NAs to 0
  deltas[is.na(deltas)]<-0
  
  for(u in 1:nrow(precipOut)){
    
    ##If any of the deltas are non-positive then set the precip to 0
    if(any(deltas[u,]<0)){
      
      precip[u]<-0
      
      wireNoise[u]<-1
      
    }
    
    ##Otherwise if the deltas are all >=0 then carry through the precip value
    else{
      
      precip[u]<-adjustedPrecip[u]
      
      wireNoise[u]<-0
    }
    
    results<-c(precip)
    wireSum<-c(wireNoise)
  
  }
  
  ##write the results to the precipOut data frame
  precipOut$radjPrecip<<-results
  precipOut$wireNoiseQF<<-wireSum
}



zeroIfNonpositiveDelta(deltas=precipOut[,c("delta1","delta2","delta3")],adjustedPrecip=precipOut$adjPrecip)

```

```{r, echo=FALSE}

###############
#Rounding data
###############

##Rounding percipitation values to the tenth decimal place and numbers ending in 5 will be rounded up.

round2 = function(x, n) {
  posneg = sign(x)
  z = abs(x)*10^n
  z = z + 0.5
  z = trunc(z)
  z = z/10^n
  z*posneg
}


##Round the precipitation values
precipOut$roundedPrecip<-round2(precipOut$radjPrecip,n=1)
```

```{r,echo=FALSE}
###############################################
# In place of USCRN code chunk - quantizeValues
###############################################

## Force any value less than 0.2 to 0
precipOut$detectablePrecip<-ifelse(precipOut$roundedPrecip<0.25,0,precipOut$roundedPrecip)

```

```{r,echo=FALSE}
################################################
## NULL if overflowing
################################################

## Force any value less than 0.2 to 0
precipOut$finalPrecip<-ifelse(precipOut$detectablePrecip>1000,0,precipOut$detectablePrecip)
precipOut$overflowQF<-ifelse(precipOut$detectablePrecip>1000,1,0)
```

```{r,echo=FALSE}
library(ggplot2)
foo<-ggplot(precipOut) + geom_point(aes(x = time, y = finalPrecip, colour =  gapQF > 0)) +
  scale_colour_manual(name = 'Gap', values = setNames(c('red','blue'),c(T, F))) +
  xlab('Time') + ylab('Precipitation (mm)')

foo

library(fields)

print(head(precipOut))
print(stats(precipOut))



foo2<-ggplot(precipOut) + geom_point(aes(x = time, y = finalPrecip, colour =  wireNoiseQF > 0)) +
  scale_colour_manual(name = 'Gap', values = setNames(c('red','blue'),c(T, F))) +
  xlab('Time') + ylab('Precipitation (mm)')

foo2

```
